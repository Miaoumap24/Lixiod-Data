<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mon WYSIWYG Trop Bien (Tim√©o)</title>
    
    <style>
    /* Styles de base et du corps */
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f7f9fc; /* Arri√®re-plan tr√®s doux */
        padding: 20px;
        margin: 0;
    }

    /* Styles pour les toolbars (barres d'outils) */
    .toolbar {
        padding: 10px;
        display: flex;
        flex-wrap: wrap; 
        gap: 10px;
        border-radius: 8px;
        margin-bottom: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }

    /* Toolbar statique (Ajouter un bloc) - Rose doux */
    #static-toolbar {
        background-color: #ffe0e6;
    }

    /* Toolbar dynamique (√âdition) - Jaune doux */
    #dynamic-toolbar {
        background-color: #fce172;
    }

    /* Classe pour masquer les toolbars */
    .hidden {
        display: none !important;
    }

    /* Styles des boutons */
    .tool-button {
        cursor: pointer;
        padding: 8px 12px;
        border: 2px solid transparent;
        border-radius: 6px;
        background-color: #a8dadc; /* Bleu-vert doux */
        color: #1d3557;
        font-weight: bold;
        transition: all 0.2s ease-in-out;
        white-space: nowrap; /* Emp√™che de couper le texte */
    }

    .tool-button:hover {
        background-color: #457b9d;
        color: white;
        border-color: #457b9d;
        transform: translateY(-1px);
    }

    /* Bouton d'exportation pour le faire ressortir */
    .export-button {
        background-color: #e63946; /* Rouge */
        color: white;
        margin-left: auto; /* Le pousse vers la droite */
    }
    .export-button:hover {
        background-color: #c72c38;
        border-color: #c72c38;
    }

    /* Styles pour les s√©lecteurs (taille/police) et le champ couleur */
    .tool-select, .tool-label {
        padding: 8px;
        border-radius: 6px;
        border: 1px solid #457b9d;
        background-color: white;
        color: #1d3557;
        cursor: pointer;
        font-weight: bold;
        white-space: nowrap;
    }
    
    .tool-label {
        display: flex;
        align-items: center;
    }

    .tool-color {
        width: 35px;
        height: 35px;
        padding: 2px;
        border: 1px solid #457b9d;
        border-radius: 6px;
        cursor: pointer;
    }


    /* Le conteneur principal de l'√©diteur */
    #editor {
        min-height: 500px;
        border: 2px dashed #a8dadc;
        padding: 20px;
        background-color: white;
        border-radius: 8px;
        transition: border-color 0.3s;
    }

    /* Styles des blocs de texte */
    .text-block {
        margin: 15px 0;
        padding: 10px;
        font-size: 16px;
        line-height: 1.6;
        border: 1px solid transparent;
        transition: border 0.2s, background-color 0.2s;
        cursor: move;
        outline: none;
    }

    /* Effet au survol des blocs */
    .text-block:hover {
        border: 1px dashed #457b9d;
        background-color: #f0f8ff;
    }

    /* Style du bloc actif (en mode √©dition) */
    .text-block.active {
        border: 2px solid #457b9d; 
        background-color: #ffffff;
    }
    
    /* Glisser-D√©poser: Style pour le bloc en cours de glissement (visuel) */
    .text-block.dragging {
        opacity: 0.4;
        border: 2px dashed #e63946 !important;
    }

    /* Glisser-D√©poser: Style pour l'endroit o√π le bloc va √™tre d√©pos√© */
    .drag-over {
        border-top: 3px solid #1d3557 !important; 
    }

    /* ‚≠ê NOUVEAU CSS POUR LES IMAGES ‚≠ê */
    .image-block {
        margin: 15px 0;
        padding: 10px;
        border: 1px solid transparent;
        transition: border 0.2s;
        cursor: move;
        text-align: center; /* Centre l'image dans le bloc */
        position: relative; /* N√©cessaire pour le redimensionnement */
        resize: both; /* Permet le redimensionnement */
        overflow: hidden; /* Cache ce qui d√©passe si l'image est redimensionn√©e */
        min-width: 50px; /* Taille minimale */
        min-height: 50px;
        border-radius: 15px; /* Coins arrondis pour le bloc image */
    }

    .image-block.active {
        border: 2px solid #457b9d; 
        background-color: #f0f8ff;
    }

    .image-block img {
        max-width: 100%; /* L'image s'adapte √† la taille du bloc */
        height: auto;
        display: block; /* Supprime l'espace sous l'image */
        margin: 0 auto; /* Centre l'image */
        border-radius: 10px; /* Coins arrondis pour l'image elle-m√™me */
    }

    /* Quand on glisse un bloc image */
    .image-block.dragging {
        opacity: 0.4;
        border: 2px dashed #e63946 !important;
    }
</style>
</head>
<body>

    <div id="static-toolbar" class="toolbar">
        <button class="tool-button" id="add-text-btn">Ajouter un bloc de texte ‚úçÔ∏è</button>
        <button class="tool-button" id="add-image-btn">Ajouter une image üñºÔ∏è</button> </div>

    <div id="dynamic-toolbar" class="toolbar hidden">
        <button class="tool-button" id="back-btn">Retour ‚¨ÖÔ∏è</button>

        <button class="tool-button" data-command="bold">Gras üÖ±Ô∏è</button>
        <button class="tool-button" data-command="italic">Italique üáÆ</button>
        <button class="tool-button" data-command="underline">Soulign√© üá∫</button>
        <button class="tool-button" data-command="createLink">Lien üîó</button>

        <select class="tool-select" data-command="fontName" id="font-select">
            <option value="">Police</option>
            <option value="Arial">Arial</option>
            <option value="Georgia">Georgia</option>
            <option value="Verdana">Verdana</option>
            <option value="Comic Sans MS">Comic Sans MS (Pour le fun !)</option>
        </select>

        <select class="tool-select" data-command="fontSize" id="size-select">
            <option value="">Taille</option>
            <option value="3">Petit</option>
            <option value="5">Moyen</option>
            <option value="7">Grand</option>
        </select>
        
        <label for="color-input" class="tool-label">Couleur üé®</label>
        <input type="color" class="tool-color" data-command="foreColor" id="color-input" value="#000000">

        <button class="tool-button export-button" id="export-btn">Exporter üì¶</button>
    </div>

    <div id="editor">
        </div>

    <script>
    // R√©f√©rences aux √©l√©ments du DOM
    const editor = document.getElementById('editor');
    const staticToolbar = document.getElementById('static-toolbar');
    const dynamicToolbar = document.getElementById('dynamic-toolbar');
    const addTextBtn = document.getElementById('add-text-btn');
    const addImageBtn = document.getElementById('add-image-btn'); // NOUVELLE R√âF√âRENCE
    const backBtn = document.getElementById('back-btn');
    const exportBtn = document.getElementById('export-btn');

    let activeBlock = null; 
    let dragElement = null; 

    // ----------------------------------------------------------------------
    // 1. GESTION DE L'AFFICHAGE DES TOOLBARS ET DES BLOCS
    // ----------------------------------------------------------------------

    function enterEditMode(block) {
        if (activeBlock) {
            activeBlock.classList.remove('active');
            activeBlock.contentEditable = 'false';
        }

        activeBlock = block;
        activeBlock.classList.add('active');
        activeBlock.setAttribute('draggable', 'false'); // D√©sactive le drag en mode √©dition

        // Pour les blocs de texte, on rend contenteditable
        if (activeBlock.classList.contains('text-block')) {
            activeBlock.contentEditable = 'true';
            activeBlock.focus();
            // Cacher la dynamic toolbar pour les images (pas de texte √† √©diter)
            // Mais si on veut pouvoir modifier l'alt ou la source, il faudra une autre toolbar
            dynamicToolbar.classList.remove('hidden'); 
            staticToolbar.classList.add('hidden');
        } 
        // Pour les blocs d'image, on ne rend pas contenteditable mais on met juste la bordure active
        else if (activeBlock.classList.contains('image-block')) {
            // Ici, on pourrait afficher une toolbar sp√©cifique pour l'image si besoin
            staticToolbar.classList.add('hidden');
            dynamicToolbar.classList.add('hidden'); // On cache la toolbar de texte pour l'image
            // Plus tard, tu pourrais cr√©er une #image-toolbar
        }
    }

    function exitEditMode() {
        if (activeBlock) {
            activeBlock.contentEditable = 'false';
            activeBlock.classList.remove('active');
            activeBlock.setAttribute('draggable', 'true'); // R√©active le drag
            activeBlock = null;
        }
        dynamicToolbar.classList.add('hidden');
        staticToolbar.classList.remove('hidden');
    }

    // ----------------------------------------------------------------------
    // 2. √âV√âNEMENTS STATIQUES (Ajouter / Clic Bloc / Retour)
    // ----------------------------------------------------------------------

    // Ajout d'un nouveau bloc de texte
    addTextBtn.addEventListener('click', () => {
        const newBlock = document.createElement('p');
        newBlock.classList.add('text-block');
        newBlock.textContent = 'Nouveau texte g√©nial !'; 
        newBlock.setAttribute('draggable', 'true'); 
        editor.appendChild(newBlock);
        enterEditMode(newBlock);
    });

    // ‚≠ê NOUVEAU : Ajout d'un nouveau bloc d'image ‚≠ê
    addImageBtn.addEventListener('click', () => {
        const imageUrl = prompt("Entre l'URL de l'image (ex: https://picsum.photos/400/300) :");
        if (imageUrl) {
            const newBlock = document.createElement('div');
            newBlock.classList.add('image-block');
            newBlock.setAttribute('draggable', 'true');
            
            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = "Image ajout√©e par l'√©diteur"; // Important pour l'accessibilit√©
            
            newBlock.appendChild(img);
            editor.appendChild(newBlock);
            enterEditMode(newBlock); // Active le bloc image (bordure et redimensionnement)
        }
    });


    // √âcouter les clics dans l'√©diteur pour passer en mode √©dition
    editor.addEventListener('click', (event) => {
        // G√®re les clics sur les blocs de texte OU les blocs d'image
        if (event.target.classList.contains('text-block') || event.target.classList.contains('image-block')) {
            enterEditMode(event.target);
        } else if (event.target.tagName === 'IMG' && event.target.closest('.image-block')) {
            // Si on clique directement sur l'image, on active son parent image-block
            enterEditMode(event.target.closest('.image-block'));
        }
    });

    // Bouton "Retour" pour sortir du mode √©dition
    backBtn.addEventListener('click', exitEditMode);

    // ----------------------------------------------------------------------
    // 3. √âV√âNEMENTS DYNAMIQUES (Commandes de Boutons : Gras, Italique, Lien)
    // ----------------------------------------------------------------------

    dynamicToolbar.addEventListener('click', (event) => {
        const target = event.target;
        const command = target.dataset.command;
        
        if (target.classList.contains('tool-button') && command) {
            if (command === 'createLink') {
                const url = prompt("Entre l'URL du lien (ex: https://www.google.com) :");
                if (url) {
                     document.execCommand('createLink', false, url);
                }
            } else {
                document.execCommand(command, false, null);
            }
            if(activeBlock) activeBlock.focus(); 
        }
    });

    // ----------------------------------------------------------------------
    // 4. √âV√âNEMENTS DYNAMIQUES (Commandes de S√©lecteurs : Police, Taille, Couleur)
    // ----------------------------------------------------------------------

    dynamicToolbar.addEventListener('change', (event) => {
        const target = event.target;
        const command = target.dataset.command;
        const value = target.value;

        if (command && value) {
            document.execCommand(command, false, value);
            
            if (target.tagName === 'SELECT') {
                target.value = ''; 
            }

            if (activeBlock) {
                 activeBlock.focus();
            }
        }
    });


    // ----------------------------------------------------------------------
    // 5. GESTION DU GLISSER-D√âPOSER (DRAG AND DROP)
    // ----------------------------------------------------------------------
    editor.addEventListener('dragstart', (event) => {
        // On rend d√©pla√ßable les blocs de texte ET les blocs image
        if (event.target.classList.contains('text-block') || event.target.classList.contains('image-block')) {
            exitEditMode(); 
            dragElement = event.target;
            dragElement.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/html', event.target.outerHTML); // outerHTML pour garder toute la structure
        }
    });

    editor.addEventListener('dragend', (event) => {
        if (dragElement) {
            dragElement.classList.remove('dragging');
            dragElement = null;
        }
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
    });

    editor.addEventListener('dragover', (event) => {
        event.preventDefault(); 
        event.dataTransfer.dropEffect = 'move';

        const target = event.target;
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        
        // Cible le parent .text-block ou .image-block
        let dropTarget = target.closest('.text-block') || target.closest('.image-block');

        if (dropTarget && dropTarget !== dragElement) {
            const rect = dropTarget.getBoundingClientRect();
            const middleY = rect.top + rect.height / 2;
            
            if (event.clientY < middleY) {
                dropTarget.classList.add('drag-over');
            } else {
                let nextSibling = dropTarget.nextElementSibling;
                // Si l'√©l√©ment suivant existe et est aussi un bloc d√©pla√ßable
                if (nextSibling && (nextSibling.classList.contains('text-block') || nextSibling.classList.contains('image-block'))) {
                    nextSibling.classList.add('drag-over');
                } else {
                    dropTarget.classList.add('drag-over'); // Sinon, on marque apr√®s l'actuel
                }
            }
        }
    });

    editor.addEventListener('drop', (event) => {
        event.preventDefault();
        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));

        // Cible le parent .text-block ou .image-block
        let dropTarget = event.target.closest('.text-block') || event.target.closest('.image-block');

        if (dragElement && dropTarget && dropTarget !== dragElement) {
            const rect = dropTarget.getBoundingClientRect();
            const middleY = rect.top + rect.height / 2;

            if (event.clientY < middleY) {
                editor.insertBefore(dragElement, dropTarget);
            } else {
                editor.insertBefore(dragElement, dropTarget.nextSibling);
            }
        } else if (dragElement && event.target === editor) {
            // Permet de d√©poser dans l'√©diteur s'il est vide ou √† la fin
            editor.appendChild(dragElement);
        }
    });

    // ----------------------------------------------------------------------
    // 6. GESTION DU BOUTON EXPORTER
    // ----------------------------------------------------------------------

    exportBtn.addEventListener('click', () => {
        exitEditMode(); 
        
        // On r√©cup√®re le HTML de TOUS les blocs d√©pla√ßables (texte et image) pour l'export
        const blocksHTML = Array.from(editor.children)
            .filter(el => el.classList.contains('text-block') || el.classList.contains('image-block'))
            .map(el => el.outerHTML)
            .join('\n');
            
        const exportContent = `<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Page Export√©e de Mon √âditeur Trop Bien</title>
</head>
<body>
    ${blocksHTML}
</body>
</html>`;

        const blob = new Blob([exportContent], { type: 'text/html' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'page_editor_timeo.html';
        
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        alert("Fichier HTML export√© avec succ√®s ! Tu g√®res ! üéâ");
    });
</script>
</body>
</html>
